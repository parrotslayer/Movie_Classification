<!DOCTYPE html  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MPLAB C Compiler for PIC18 MCUs Release Notes</title>
<style type="text/css">
span {
	font-family: Arial;
	color: #000000;
	background: #FFFFFF;
	font-size: 10pt;
}
pre {
	font-family: monospace;
	color: #000000;
	background: #FFFFFF;
	font-size: 10pt;
}
p.Heading0, li.Heading0, div.Heading0, span.Heading0 {
	font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;
}
h1 {
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.3in;
	text-indent:-.3in;
	page-break-after:avoid;
	tab-stops:list .3in;
	font-size:14.0pt;
	font-family:Arial;
}
h2 {
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.4in;
	text-indent:-.4in;
	page-break-after:avoid;
	mso-outline-level:2;
	tab-stops:list .4in;
	font-size:12.0pt;
	font-family:Arial;
}
DL, DT, OL, UL, LI, DD {
    list-style-position: outside;
}
pre {
    font-family: monospace;
}
code {
    font-family: monospace;
}
</style>
</head>
<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>
<span><div class=Heading0>Release Notes for MPLAB&reg; C Compiler for PIC18 MCUs v3.47 <br /></div>
13 Nov 2013<br />
<br />
<div class=Heading0>Table of Contents</div>
<OL>

<LI><A HREF="#StandardEvaluationEdition" TITLE="Jump to 'How the Standard
       Evaluation Edition Differs from the Full Version' Section">How the
       Standard Evaluation Edition Differs from the Full Version</A></LI>
<LI><A HREF="#Compatibility" TITLE="Jump to 'Important Backward Compatibility
       Notes'
       Section">Important Backward Compatibility Notes</A></LI>
<LI><A HREF="#WhatsNew" TITLE="Jump to 'What&apos;s New in This Release'
       Section">What's New in This Release</A></LI>
<LI><A HREF="#Fixed" TITLE="Jump to 'What&apos;s Been Fixed Since v3.30'
       Section">What's Been Fixed Since v3.30</A></LI>
<LI><A HREF="#Devices" TITLE="Jump to 'Devices Supported'
       Section">Devices Supported</A></LI>
<LI><A HREF="#Documentation" TITLE="Jump to 'MPLAB C Compiler for PIC18 MCUs
       Documentation'
       Section">MPLAB C Compiler for PIC18 MCUs Documentation</A></LI>
<LI><A HREF="#Installation and Upgrades" TITLE="Jump to
       'Installation and Upgrades' Section">Installation and Upgrades</A></LI>
<LI><A HREF="#IDE" TITLE="Jump to 'Using MPLAB C18 with the MPLAB IDE'
       Section">Using MPLAB C Compiler for PIC18 MCUs with the MPLAB IDE</A>
       </LI>
<LI><A HREF="#KnownProblems" TITLE="Jump to 'Known Problems'
       Section">Known Problems</A></LI>
<LI><A HREF="#Contributors" TITLE="Jump to 'Contributors'
       Section">Contributors</A></LI>
<LI><A HREF="#Support" TITLE="Jump to 'Customer Support'
       Section">Customer Support</A></LI>
</OL>
<OL style="list-style-type:decimal;">
<LI class="Heading0"><h1><A NAME="StandardEvaluationEdition">
        How the Standard Evaluation Edition Differs from the Full Version
        </A></h1>
<span style="font-size:10pt;font-weight:normal;">
        <p>MPLAB C Compiler for PIC18 MCUs is available as either a Standard
        Evaluation Edition or a full version.  This Read Me file is the same
        in both.</p>

        <p>For 60 days, the Standard Evaluation Edition of MPLAB C Compiler
        for PIC18 MCUs will function as the full version. After 60 days, the
        MPLAB C Compiler for PIC18 MCUs Standard Evaluation Edition differs
        from the full version in the following ways:
<UL>
        <LI>Not all optimizations will be supported. Namely, procedural
        abstraction will not be supported.</LI>
        <LI>The PIC18 Extended mode (extended instruction set and indexed with
        literal offset addressing) will not be supported.</LI>
</UL></p><p>
        To purchase a full version of the MPLAB C Compiler for PIC18 MCUs,
        please contact your local distributor or visit
        <A HREF="http://www.microchip.com/c18">http://www.microchip.com/c18</A>.
</p>
</span>
<LI class="Heading0"><h1><A NAME="Compatibility">
        Important Backward Compatibility Notes</A></h1></LI>
<span style="font-size:10pt;font-weight:normal;">
        <h2>COFF File Format Replaces COD File Format</h2>
        <p>Due to the elimination of the COD Format from MPASM ouput, and the
        use of COFF format instead, new flags have been added to COFF files
        that are generated by C18 v3.30 and MPASM v5.30. These flags are only
        recognized by MPLINK v4.30 and above. MPLINK v4.30 and above continue
        to recognized the old COFF files, however, earlier version of MPLINK
        may not recognized new COFF files.</p>

        <h2>Corrected behavior for programs with no high priority Interrupt
        Service Routine (ISR) due to removal of the vectors region from linker
        scripts</h2>
        <p>This note is only applicable to programs with the following
        characteristics:
        <OL style="list-style-type:decimal;">
        <LI>Explicitly defined low priority ISR and </LI>
        <LI>No defined high priority ISR and </LI>
        <LI>Has the High priority interrupt enabled (either explicity or
        by not disabling the default) </LI></OL>
        <p>In the previous versions of the linker scripts (with the vectors
        region), no code or data was being placed between the High/Low-priority
        interrupt vectors.  Consequently, with the arrival of a High-priority
        interrupt, the execution of the program would (erroneously) fall into
        the low-priority ISR.  With the removal of the vectors region from the
        linker scripts, other data or code may be placed at the addresses
        between the High and Low priority interrupt vectors.  This results in
        a non-deterministic behavior, upon the arrival of a high priority
        interrupt for these programs.

        <h2>MPLAB C Compiler for PIC18 MCUs Storage Qualifier Handling</h2>
        <p>The changes to fix SSR 22612 in MPLAB C18 v3.06 affect programs
        written without consideration of C language specifications
        regarding the syntactic use of <code>const</code>,
        <code>volatile</code>, <code>rom</code>, <code>ram</code>,
        <code>near</code>, and <code>far</code> qualifiers for user
        defined types using <code>typedef</code>.  An error or a warning
        will be generated if the compiler detects such problems in code.</p>

        <p>For example in the following code:</p>
<pre>
typedef char * cPtr_t;
cPtr_t rom rompc;
rom char romc;
void f(void)
{
  rompc = &romc;
}
</pre>
        <p><code>rompc</code> should be <code>[rom pointer to ram char]</code>
        so MPLAB C18 v3.06 and later produce a warning indicating there is a
        qualifier mismatch in assignment.  Please note that this program
        compiles with no warning in MPLAB C Compiler for PIC18 MCUs prior to
        this fix because in
        those versions, <code>rompc</code> was incorrectly qualified as
        <code>[ram pointer to rom char]</code>.  Since <code>romc</code> was
        in rom there was no mismatch in type and qualification for this
        assignment in earlier versions of MPLAB C Compiler for PIC18 MCUs. </p>

        <p> The qualifiers <code>rom</code>, <code>ram</code>,
        <code>near</code>, and <code>far</code> are specific to MPLAB C
        Compiler for PIC18 MCUs.
        While different from <code>const</code> and <code>volatile</code>
        from a semantic point of view, they are parsed in the same syntactic
        context, hence the above example is applicable to all qualifiers.  (For
        more information on the syntax of using qualifiers please refer to your
        C programming language reference manual.  For a description of
        <code>rom</code>, <code>ram</code>, <code>near</code>, and
        <code>far</code> qualifiers please refer to the "Storage Qualifiers"
        section of the MPLAB C18 C Compiler User's Guide.) </p>

<h2>MPLINK&trade; Linker and MPLAB IDE COFF File Format</h2>
        <p>Due to a change in COFF file format, MPLAB C18 v3.00 and later will
        not be compatible with versions of MPLINK Linker prior to v4.00 or
        versions of the MPLAB IDE prior to v7.21.</p>

        <p>MPLAB C18 v3.00 and later will have backward compatibility to earlier
        versions at the source level only. Any existing object files or
        libraries compiled with earlier versions of the tools will not link
        using new versions of the tools. They will need to be recompiled
        from source.</p>

        <p>If the user attempts to use this release with object files or
        libraries compiled with earlier versions of MPLAB C18, MPLINK Linker,
        and MPASM Assembler, the error message that will be received will be
        similar to:</p>
        <code>
        Error - Coff file format for 'C:\mcc18\lib/c018i.o' is out of date.
        </code>
        <p>If the user attempts to use an old version of MPLINK Linker to link
        object files or libraries compiled with this release, the error message
        that will be received will be similar to:</p>
        <code>
        Error - Coff file format for 'C:\mcc18\lib/c018i.o' does not appear
        to be a valid COFF file.
        </code>
</span>

<LI class="Heading0"><h1><A NAME="WhatsNew">What's New in This Release</A></h1>
<span style="font-size:10pt;font-weight:normal;">
<UL>
<!--
        <LI>Early adopter part support has been added. See <A HREF="#Devices"
        TITLE="Jump to 'Devices Supported' Section">"Devices Supported"</A>
        below.</LI> <br />
<br />
        <LI>Several bug fixes. See <A HREF="#Fixed" TITLE="Jump to 'What&apos;s
        Been Fixed Since v3.30' Section">"What's Been Fixed Since v3.30"</A>
        below.</LI> <br />
-->
        <LI>Early adopter part support has been added. See <A HREF="#Devices"
        TITLE="Jump to 'Devices Supported' Section">"Devices Supported"</A>
        below.</LI> <br />

        <LI>A bug fix. See <A HREF="#Fixed" TITLE="Jump to 'What&apos;s
        Been Fixed Since v3.00' Section">"What's Been Fixed Since v3.30"</A>
        below.</LI> <br /><br />

</UL>
</span>

<LI class="Heading0"><h1><A NAME="Fixed">
        What's Been Fixed Since v3.30:</A></h1>
<span style="font-size:10pt;font-weight:normal;">
<OL style="list-style-type:lower-alpha;font-weight:bold;"><br />

        <LI>Fixed between v3.46 and v3.47:
<DL style="font-weight:normal;"><br />

<DT>( <b>MPASM-417</b></A>)</DT><DD> p16F1xxx.inc has the 16LF1788 and 16LF1789 as IFNDEF, should be IFDEF..
</DL>
        <LI>Fixed between v3.45 and v3.46:
<DL style="font-weight:normal;"><br />

<DT>( <b>MPASM-392</b></A>)</DT><DD> All partsupport files are now in lowercase.

<DT>( <b>C18-613</b></A>)</DT><DD> Code containing calls to 'WriteI2C', 'GetsI2C','puts12C' failed to link.

<DT>( <b>MPASM-410</b></A>)</DT><DD> All linker scripts are now in lowercase.
</DL>
        <LI>Fixed between v3.44 and v3.45:
<DL style="font-weight:normal;"><br />

<DT> Updated header files for 18F97J94 family devices</DT>
</DL>

        <LI>Fixed between v3.43 and v3.44:
<DL style="font-weight:normal;"><br />

<DT>( <b>PERLIB-84</b></A>)</DT><DD> The Library routines (write_B, EraseFlash and WriteWordFlash are modified
       to restore the original state of the GIE bit when leaving the library function.

<DT>( <b>CAEDTISS-641</b></A>)</DT><DD> Corrected adc.h to use appropriate names.

<DT>( <b>CAEDTISS-804</b></A>)</DT><DD> Corrected name of bit (WDTCONbits.DEVCFG) to (WDTCONbits.ADSHR) used in OpenADC.c

<DT>( <b>CAEDTISS-834</b></A>)</DT><DD> Added a new ADC subversion for 18F87J50 Family devices

<br /> </DT>
</DL>

        <LI>Fixed between v3.42 and v3.43:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-599</b></A>)</DT><DD> memcpypgr2ram wrong behaviour from small to large memory for PIC18F66K22.

<br /> </DT>
</DL>

        <LI>Fixed between v3.41 and v3.42:
<DL style="font-weight:normal;"><br />

<DT>None</DT>
</DL>
        <LI>Fixed between v3.40 and v3.41:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-585</b></A>)</DT><DD>Flash library will not build for devices
       that don't have EEPGD bit in EECON1.

<br /> </DT>
</DL>
        <LI>Fixed between v3.39 and v3.40:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-580</b></A>)</DT><DD>Incorrect SFR definitions in 14 Header
       Files (16-bit SFRs) Caused Compiler to treat it as an 8-bit SFRs.

<br /> </DT>
</DL>
        <LI>Fixed between v3.38 and 3.39:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-574</b></A>)</DT><DD>ccp and src folders have restricted access.

<DT>( <b>C18-575</b></A>)</DT><DD>MCC_INCLUDE and PATH for user environment
       varible not being updated properly.

<DT>( <b>C18-576</b></A>)</DT><DD>C18 pconfig.h missing ECC definition for
       PIC18F45K20 family.

<br /> </DT>
</DL>

        <LI>Fixed between v3.37 and 3.38:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-489</b></A>)</DT><DD>Handling of enumerated type is incorrect.

<DT>( <b>C18-525</b></A>)</DT><DD>Several bit field definitions in the header
       file do not match datasheet for 18F47J53 family. <br/>
       Remove: ODCON3 bit CTMUDS; ANCON1 bit VBG2EN; LATC bit LATC4; LATC bit
       LATC5; LATA bit LATA4; TRISC bit TRISC4; TRISC bit TRISC5. <br/>
       Correct names: CMSTAT bit C3OUT should be bit COUT3; PORTB bit CTEDG1
       should be bit CTED1; PORTB bit CTEDG2 should be bit CTED2.

<DT>( <b>C18-566</b></A>)</DT><DD>Make C18 display resource file version
       number in its version banner

<DT>( <b>C18-570</b></A>)</DT><DD>In the header file for PIC18FJ devices,
       16-bit combined SFR's have been defined as a 'char' which makes the
       compiler treat it like a 8-bit SFR


<DT>( <b>UDBC-204</b></A>)</DT><DD>CONFIG1H (bit 5) should be unimplemented
       for 18F87K22 and 18F87K90 family

<br /> </DT>
</DL>

        <LI>Fixed between v3.36 and 3.37:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-495</b></A>)</DT><DD>Implementaion Issues for 18F8720 Family.<br/>
      18F6520/8520 only: T1OSCMX bit was added for CONGFIG3H.<br/>
      18F6620/6720 only: AD15:AD00 removed from PORTD and PORTE (64-pin
      devices do not support external memory).<br/>
      18F6620/6720/8620/8720 only: PORTB bit CCP2 now called out as CCP2_PORTB.
      PORTF bits C1OUT and C2OUT now called out as C1OUT_PORTF and C2OUT_PORTF.
      <br/>
      18F8620/8720: PORTH bits AD19:AD16 renamed to A19:A16 (address only not
      address/data).  PORTH bits AD15:AD12 renamed to AN15:AN12 (analog not
      address/data).

<DT>( <b>C18-496</b></A>)</DT><DD>Bits have been removed from 18F1320/1220
      Family. <br/>
      LATA.LATA5 (RA5 is an input only) <br/>
      DDRA.RA5 (RA5 is an input only) <br/>
      PIE2.EDDIE, PIR2.EDDIF, and IPR2.EDDIP (not implemented on these devices)

<DT>( <b>C18-497</b></A>)</DT><DD>Bits have been removed from 18F452 Family.
      <br/>
      18F252 and 18F242 only: <br/>
      PIE1.PSPIE, PIR1.PSPIF, and IPR1.PSPIP have been removed (no Parallel
      Slave Port on 28-pin devices). <br/>
      18F452, 18F442, 18F252 and 18F242: <br/>
      RCON.nLWRT and RCON.LWRT have been removed (bits for 18Cxxx devices
      not 18Fxxx devices). <br/>
      INTCON2.INT3P and INTCON2.INTEDG3 have been removed (no INT3).

<DT>( <b>C18-499</b></A>)</DT><DD> Bits have been removed from 18C452 Family.
      <br/>
      18C452, 18C442, 18C252, 18C242: <br/>
      Removed ADCON1.VCFG0 and ADCON1.VCFG1 <br/>
      18C252, 18C242 Only: <br/>
      PIE1.PSPIE, PIR1.PSPIF, and IPR1.PSPIP have been removed (no Parallel
      Slave Port on 28-pin devices).


<DT>( <b>C18-500</b></A>)</DT><DD>Bits have been removed from 18F4539 Family.
      <br/>
      18F4539, 18F4439, 18F2539, 18F2439: <br/>
      RCON.nLWRT and RCON.LWRT have been removed (bits for 18Cxxx devices not
      18Fxxx devices).


<DT>( <b>C18-501</b></A>)</DT><DD>Bits have been removed from 18F458 Family.
      <br/>
      18F458, 18F448, 18F258, 18F248: <br/>
      DDRA.RA7 has been removed (no RA7 on these devices). <br/>
      INTCON2.INTEDG2 has been removed. <br/>
      18F258, 18F248 only: <br/>
      PIE1.PSPIE, PIR1.PSPIF, and IPR1.PSPIP were removed (no Parallel Slave
      Port on 28-pin devices).

<DT>( <b>C18-502</b></A>)</DT><DD>Bits have been removed from 18C858 Family.
      <br/>
      18F858, 18F658: <br/>
      Removed TXB2SIDL.SRR, TXB1SIDL.SRR, and TXB0SIDL.SRR <br/>
      PORTE bits (ALE, OE, WRL, and WRH) were removed - family does not support
      external memory. <br/>
      PORTD bits (AD<7:0) were removed - family does not support external
      memory. <br/>
      18F858 Only: <br/>
      PORTH bits (A<19:16> were removed - family does not support external
      memory. <br/>
      PORTJ bits (AD<15:8> were removed - family does not support external
      memory.

<DT>( <b>C18-503</b></A>)</DT><DD>Bits have been removed from 18C801 Family.
      <br/>
      18C801, 18C601: <br/>
      INTCON2.INTEDG3 has been removed (no INT3). <br/>
      PORTB.INT3 has been removed (no INT3). <br/>
      18C801 only: <br/>
      PORTH<AN15:12> have been removed (only has 12 analog channels AN<11:0>).

<DT>( <b>C18-504</b></A>)</DT><DD>Bits have been removed from 18F4320 Family.
      <br/>
      18F2320 and 18F2220 only: <br/>
      PORTE has been removed (no PORTE on 28-pin devices, 28-pin devices have
      no RE3 on the MCLR pin). <br/>
      Removed CCP1CON.P1M0, and CCP1CON.P1M1 - unimplimented on 28-pin devices).
      <br/>
      18F4320, 18F4220, 18F2320, 18F2220: <br/>
      OSCTUNE2 (Register added on rev C0 devices) This removes the BADRAM
      location F9A from the old include files.


<DT>( <b>C18-505</b></A>)</DT><DD>Bits have been changed in 18F4431 Family.
      <br/>
      18F4431, 18F4331, 18F2431, 18F2331 : <br/>
      AN4 was in bit postion 5 (RA5), now in bit position 4 (RA4). <br/>
      WDTCON<6:0> have been removed. <br/>
      18F4431, 18F4331 only: <br/>
      RE<7:4> have been removed (family only has RE<3:0>). <br/>
      LATE<7:3> have been removed (family only has RE<3:0>, RE3 is input only).
      <br/>
      DDRE.RE<7:3> have been removed (family only has RE<3:0>, RE3 is input
      only). <br/>
      18F2431 only: <br/>
      Added CONFIG6L.WRT3 and CONFIG6L.WRT2 (data sheet is in error it is the
      2431/4431 that should have them (16kB devices)) <br/>
      Added CONFIG6L.EBTR3 and CONFIG6L.EBTR2 (data sheet is in error it is the
      2431/4431 that should have them (16kB devices)) <br/>
      18F4331 only: <br/>
      Removed CONFIG6L.WRT3 and CONFIG6L.WRT2 (data sheet is in error it is the
      2331/4331 that should not have them (8kB devices)) <br/>
      Removed CONFIG6L.EBTR3 and CONFIG6L.EBTR2 (data sheet is in error it is
      the 2331/4331 that should not have them (8kB devices))


<DT>( <b>C18-506</b></A>)</DT><DD>Bits have been removed from 18F8621 Family.
      <br/>
      18F8621, 18F8525, 18F6621, 18F6525:<br/>
      LATG.LATG5 has been removed (RG5 is input only).<br/>
      DDRG.RG5 has been removed (RG5 is input only).<br/>
      RCON.nLWRT and RCON.LWRT have been removed (18Cxxx parts only).<br/>
      18F6621, 18F6525 only:<br/>
      PORTD.AD<7:0> have been removed (64-pin devices do not support external
      memory).

<DT>( <b>C18-507</b></A>)</DT><DD>Bits have been removed (18F8680 Family).
      <br/>
      18F8680, 18F8585, 18F6680, 18F6585:<br/>
      LATG.LATG5 has been removed (RG5 is input only).<br/>
      DDRG.RG5 has been removed (RG5 is input only).

<DT>( <b>C18-508</b></A>)</DT><DD>Bits have been moved/removed in 18F1330
      Family.  <br/>
      18F1330, 18F1230:<br/>
      DDRA.RA5 has been removed (RA5 is input only).<br/>
      STKPTR.STKFUL has been moved from bit 6 to bit 7 (where it belongs).<br/>
      CONFIG2L.BORV<2:0> mask has changed from 0xC to 0x18 (corrected wrong
      mask value)


<DT>( <b>C18-509</b></A>)</DT><DD>Bits have been moved/removed in 18F4321 Family
      .  <br/>
      18F4321 only: <br/>
      Bits (HLVDL<3:0>, IVRST, VDIRMAG, LVDL<3:0>, LVV<3:0>, LVDEN, and BGST
      <br/>
      have been moved from OSCCON to HLVDCON where they belong. <br/>
      18F4321, 18F4221 only: <br/>
      CONFIG4L.ICPRT has been removed (reserved bit now hidden). <br/>
      18F2321, 18F2221 only: <br/>
      CCP1CON<P1M0> and CCP1CON<P1M1> have been removed (unimplemented on
      28-pin devices).


<DT>( <b>C18-510</b></A>)</DT><DD>Bits have been removed from 18F4450 Family.
      <br/>
      CONFIG4L.ICPRT has been removed

<DT>( <b>C18-511</b></A>)</DT><DD>Bits have been renamed in 18F4580 Family.
      <br/>
      18F4580, 18F4480, 18F2580, 18F2480:<br\>
      Registers CANSTAT_RO0, RO1, RO2, RO3, RO4, RO5, RO6 RO7, RO8, RO9:<br\>
      bit OPMODE has been renamed to OPMODE0<br\>
      bit REQOP1 has been renamed to OPMODE1 (note REQOP1 is in
      CANCON_RO0...CANCON_RO9 not CANSTAT)<br\>
      bit REQOP2 has been renamed to OPMODE2 (note REQOP2 is in
      CANCON_RO0...CANCON_RO9 not CANSTAT)

<DT>( <b>C18-512</b></A>)</DT><DD>Bits have been renamed in 18F4680 Family.
      <br/>
      18F4680, 18F4585, 18F2680, 18F2585:<br/>
      Registers CANSTAT_RO0, RO1, RO2, RO3, RO4, RO5, RO6 RO7, RO8, RO9:<br/>
      bit OPMODE has been renamed to OPMODE0<br/>
      bit REQOP1 has been renamed to OPMODE1 (note REQOP1 is in CANCON_RO0...CANCON_RO9 not CANSTAT)<br/>
      bit REQOP2 has been renamed to OPMODE2 (note REQOP2 is in CANCON_RO0...CANCON_RO9 not CANSTAT)

<DT>( <b>C18-513</b></A>)</DT><DD>Bits have been renamed in 18F4685 Family.
      <br/>
      18F4685, 18F4682, 18F2685, 18F2682:<br/>
      Registers CANSTAT_RO0, RO1, RO2, RO3, RO4, RO5, RO6 RO7, RO8, RO9:<br/>
      bit OPMODE has been renamed to OPMODE0<br/>
      bit REQOP1 has been renamed to OPMODE1 (note REQOP1 is in CANCON_RO0...CANCON_RO9 not CANSTAT)<br/>
      bit REQOP2 has been renamed to OPMODE2 (note REQOP2 is in CANCON_RO0...CANCON_RO9 not CANSTAT)


<DT>( <b>C18-514</b></A>)</DT><DD>Bits have been removed in 18F4610 Family.
      <br/>
      18F4610, 18F4515, 18F4410, 18F2610, 18F2515, 18F2410:<br/>
      PORTB.DAD5, PORTB.DAD6, and PORTB.DAD7 have been removed (emulator only
      pin function).

<DT>( <b>C18-515</b></A>)</DT><DD>Register has been removed in 18F4620 Family.
      <br/>
      18F4620, 18F4525, 18F2620, 18F2525:<br/>
      DEBUG register has been removed (FD4h is an unimplemented register).


<DT>( <b>C18-516</b></A>)</DT><DD>Bits have been removed in 18F8490 Family.
      <br/>
      18F8490, 18F8390, 18F6490, 18F6390:<br/>
      PORTD<AD7:AD0> has been removed (External memory is not supported on this
      family).<br/>
      PORTE<AD15:AD8> has been removed (External memory is not supported on
      this family).

<DT>( <b>C18-517</b></A>)</DT><DD>Bits have been removed in 18F8493 Family.
      <br/>
      18F8493, 18F8393, 18F6493, 18F6393: <br/>
      PORTD<AD7:AD0> has been removed (External memory is not supported on this
      family). <br/>
      PORTE<AD15:AD8> has been removed (External memory is not supported on
      this family).

<DT>( <b>C18-518</b></A>)</DT><DD>Register has been removed in 18F14K22 Family.
      <br/>
      18F14K22, 18F13K22, 18LF14K22, 18LF13K22: <br/>
      EEADRH has been removed, family only has 256 bytes of data eeprom
      (handled by EEADR register). <br/>
      (data sheet is in error and will be updated in the future to remove the
      register)

<DT>( <b>C18-519</b></A>)</DT><DD>Register has been removed in 18F14K50 Family.
      <br/>
      18F14K50, 18F13K50, 18LF14K50, 18LF13K50: <br/>
      EEADRH has been removed, family only has 256 bytes of data eeprom
      (handled by EEADR register). <br/>
      (data sheet is in error and will be updated in the future to remove the
      register)

<DT>( <b>C18-520</b></A>)</DT><DD>Bits have been removed in 18F46K20 Family.
      <br/>
      18F26K20, 18F25K20, 18F24K20, 18F23K20: <br/>
      The following bits have been removed since they are not supported on
      28-pin devices: SLRCON.SLRD, SLRCON.SLRE, ANSEL.ANS5, ANSEL.ANS6,
      ANSEL.ANS7, PIE1.PSPIE, PIR1.PSPIF, and IPR1.PSPIP


<DT>( <b>C18-521</b></A>)</DT><DD>Registers have been removed from 18F85J90
      Family. <br/>
      18F65J90, 18F64J90, 18F63J90: <br/>
      The following registers are not implemented on 64-pin packages so they
      have been removed: DDRH, DDRJ, TRISH, and TRISJ

<DT>( <b>C18-522</b></A>)</DT><DD>Bits have been moved / removed in 18F87J10
      Family). <br/>
      18F87J10, 18F86J15, 18F86J10, 18F85J15, 18F85J10, 18F67J10, 18F66J15,
      18F66J10, 18F65J15, 18F65J10: <br/>
      PORTB.PGM has been removed (no PGM pin for these parts) <br/>
      PORTB.PGC has moved from bit 5 to bit 6 (PGC is bit 6 not 5) <br/>
      PORTB.PGD has moved from bit 6 to bit 7 (PGD is bit 7 not 6) <br/>
      18F67J10, 18F66J15, 18F66J10, 18F65J15, 18F65J10 Only Unify Issues: <br/>
      PORTD<AD07:AD00> has been removed (no external memory support on 64-pin
      devices) <br/>
      PORTE<AD15:AD8> has been removed (no external memory support on 64-pin
      devices) <br/>


<DT>( <b>C18-523</b></A>)</DT><DD>Bits have been moved from 18F87J11 Family.
      <br/>
      18F87J11, 18F86J16, 18F86J11, 18F67J11, 18F66J16, 18F66J11: <br/>
      PORTB.PGC has moved from bit 5 to bit 6 (PGC is bit 6 not 5) <br/>
      PORTB.PGD has moved from bit 6 to bit 7 (PGD is bit 7 not 6)

<DT>( <b>C18-524</b></A>)</DT><DD>Bit has been removed from 18F87J50 Family.
      <br/>
      18F87J50, 18F86J55, 18F86J50, 18F85J50, 18F67J50, 18F66J55, 18F66J50,
      18F65J50: <br/>
      DDRF.RF1 has been removed (RF1 does not exist on this family).

<br /> </DT>
</DL>

        <LI>Fixed between v3.35 and 3.36:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-489</b></A>)</DT><DD>Handling of enumerated type is incorrect.

<DT>( <b>C18-525</b></A>)</DT><DD>Several bit field definitions in the header
       file do not match datasheet for 18F47J53 family. <br/>
       Remove: ODCON3 bit CTMUDS; ANCON1 bit VBG2EN; LATC bit LATC4; LATC bit
       LATC5; LATA bit LATA4; TRISC bit TRISC4; TRISC bit TRISC5. <br/>
       Correct names: CMSTAT bit C3OUT should be bit COUT3; PORTB bit CTEDG1
       should be bit CTED1; PORTB bit CTEDG2 should be bit CTED2.

<DT>( <b>C18-526</b></A>)</DT><DD>Several bit field definitions in the header
       file do not match datasheet for 18F47J13 family. <br/>
       Remove: ANCON0 bit PCFG5; ANCON1 bit VBG2EN. <br/>
       Correct names: CMSTAT bit C3OUT should be bit COUT3; PORTB bit CTEDG1
       should be bit CTED1; PORTB bit CTEDG2 should be bit CTED2.

<DT>( <b>C18-529</b></A>)</DT><DD>Several bit field definitions in the header
       file do not match datasheet for 18F87K22 family. <br/>
       Remove: ODCON3 bits CTMUREF0 and CTMUREF1; RTCVALH bits WAITE0, WAITE1,
       WAITM0..WAITM3, WAITB0, and WAITB1; TMR7L bits CAL0..CAL7. <br/>
       Add: ECCP3DEL (18F67K22 ONLY) bits P3DC0..P3DC6; and CCPR3 (18F65K22,
       18F66K22 ONLY). <br/>
       Correct names: PORTA bit ULPWUIN> should be bit ULPWU and bit LVDIN
       should be bit HLVDIN; PORTB bit CCP2_PA2 should be bit CCP2_P2A;
       PORTC bit PA2_PORTC should be bit P2A_PORTC and bit PA1 should be bit
       P1A; PORTD bit SS2 should be bit NOT_SS2; PORTE bit PD2 should be bit
       P2D, bit PC2 should be bit P2C, bit RD should be bit NOT_RD, bit PB2
       should be bit P2B, bit PC3 should be bit P3C, bit PC1 should be bit
       P1C, and bit PB1 should be bit P1B.


<DT>( <b>UDBC-204</b></A>)</DT><DD>CONFIG1H (bit 5) should be unimplemented
       for 18F87K22 and 18F87K90 family

<br /> </DT>
</DL>

        <LI>Fixed between v3.34 and 3.35:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-252</b></A>)</DT><DD>Problem with strncmppgm function.

<br /> </DT>
</DL>

        <LI>Fixed between v3.33 and 3.34:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-56</b></A>)</DT><DD>Referencing a variable declared
       'extern' with an initializer causes an internal failure.

<DT>( <b>C18-109</b></A>)</DT><DD>A local variable declared 'rom'
       and 'extern' is disallowed when it should be permitted.

<DT>( <b>C18-460</b></A>)</DT><DD>Inconsistency of PIC18 I2C peripheral
       library code during NACK detection in Slave mode.

<DT>( <b>C18-463</b></A>)</DT><DD>WriteWord function in Flash support
       does not write data correctly.

<br /> </DT>
</DL>

        <LI>Fixed between v3.32 and 3.33:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-454</b></A>)</DT><DD> Warning message for type mismatch should
       be reverted back to message level.


<br /> </DT>
</DL>

        <LI>Fixed between v3.31 and 3.32:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-441</b></A>)</DT><DD>Message is generated instead of warning
       for type mismatch.

<DT>( <b>C18-430</b></A>)</DT><DD>volatile does not force read.

<DT>( <b>C18-297</b></A>)</DT><DD>Rand() function does not set bank
       properly before incrementing variable Seed in extended mode.

<DT>( <b>C18-291</b></A>)</DT><DD>strlenpgm for small memory model corrupts
       byte on stack.

<DT>( <b>C18-108</b></A>)</DT><DD>Add support for #message (or #warning)
       directive to preprocessor language.

<br /> </DT>
</DL>

        <LI>Fixed between v3.30 and 3.31:
<DL style="font-weight:normal;"><br />

<DT>( <b>C18-359</b></A>)</DT><DD>Win 2000 incompatibility, problem with
       msvcrt.dll

<br /> </DT>

</DL>

</OL>
</span>
<LI class="Heading0"><h1><A NAME="Devices">Devices Supported</A></h1>
<span style="font-size:10pt;font-weight:normal;"> <br />
        The MPLAB C Compiler for PIC18 MCUs (MCC18.EXE) is an ANSI C
        compiler for the
        PIC18 family of PIC microcontrollers. It currently supports the
        following PIC MCUs:
<pre>
PIC18C242       PIC18C252       PIC18C442       PIC18C452
PIC18C601       PIC18C658       PIC18C801       PIC18C858

PIC18F1220      PIC18F1230      PIC18F1320      PIC18F1330
PIC18F13K22     PIC18F13K50     PIC18F14K22     PIC18F14K22LIN
PIC18F14K50
PIC18F2220      PIC18F2221      PIC18F2320      PIC18F2321
PIC18F2331      PIC18F23K20     PIC18F23K22     PIC18F2410
PIC18F242       PIC18F2420      PIC18F2423      PIC18F2431
PIC18F2439      PIC18F2450      PIC18F2455      PIC18F2458
PIC18F248       PIC18F2480      PIC18F24J10     PIC18F24J11
PIC18F24J50     PIC18F24K20     PIC18F24K22     PIC18F24K50
PIC18F2510      PIC18F2515      PIC18F252       PIC18F2520
PIC18F2523      PIC18F2525      PIC18F2539      PIC18F2550
PIC18F2553      PIC18F258       PIC18F2580      PIC18F2585
PIC18F25J10     PIC18F25J11     PIC18F25J50     PIC18F25K20
PIC18F25K22     PIC18F25K50     PIC18F25K80
PIC18F2610      PIC18F2620      PIC18F2680      PIC18F2682
PIC18F2685      PIC18F26J11     PIC18F26J13     PIC18F26J50
PIC18F26J53     PIC18F26K20     PIC18F26K22     PIC18F26K80
PIC18F27J13     PIC18F27J53
PIC18F4220      PIC18F4221      PIC18F4320      PIC18F4321
PIC18F4331      PIC18F43K20     PIC18F43K22     PIC18F4410
PIC18F442       PIC18F4420
PIC18F4423      PIC18F4431      PIC18F4439      PIC18F4450
PIC18F4455      PIC18F4458      PIC18F448       PIC18F4480
PIC18F44J10     PIC18F44J11     PIC18F44J50     PIC18F44K20
PIC18F44K22     PIC18F4510      PIC18F4515
PIC18F452       PIC18F4520      PIC18F4523      PIC18F4525
PIC18F4539      PIC18F4550      PIC18F4553      PIC18F458
PIC18F4580      PIC18F4585      PIC18F45J10     PIC18F45J11
PIC18F45J50     PIC18F45K20     PIC18F45K22     PIC18F45K50
PIC18F45K80     PIC18F4610      PIC18F4620
PIC18F4680      PIC18F4682      PIC18F4685      PIC18F46J11
PIC18F46J13     PIC18F46J50     PIC18F46J53     PIC18F46K20
PIC18F46K22     PIC18F46K80     PIC18F47J13     PIC18F47J53
PIC18F6310
PIC18F6390      PIC18F6393      PIC18F63J11     PIC18F63J90
PIC18F6410      PIC18F6490      PIC18F6493      PIC18F64J11
PIC18F64J90     PIC18F6520
PIC18F6525      PIC18F6527      PIC18F6585      PIC18F65J10
PIC18F65J11     PIC18F65J15     PIC18F65J50     PIC18F65J90
PIC18F65J94    PIC18F65K22      PIC18F65K80     PIC18F65K90
PIC18F6620      PIC18F6621      PIC18F6622      PIC18F6627
PIC18F6628      PIC18F6680      PIC18F66J10     PIC18F66J11
PIC18F66J15     PIC18F66J16     PIC18F66J50     PIC18F66J55
PIC18F66J60     PIC18F66J65     PIC18F66J90     PIC18F66J93
PIC18F66J94     PIC18F66J99     PIC18F66K22
PIC18F66K80     PIC18F66K90
PIC18F6720      PIC18F6722      PIC18F6723      PIC18F67J10
PIC18F67J11     PIC18F67J50     PIC18F67J60     PIC18F67J90
PIC18F67J93     PIC18F67J94     PIC18F67K22     PIC18F67K90
PIC18F8310      PIC18F8390      PIC18F8393      PIC18F83J11
PIC18F83J90     PIC18F8410      PIC18F8490
PIC18F8493      PIC18F84J11     PIC18F84J90
PIC18F8520      PIC18F8525      PIC18F8527      PIC18F8585
PIC18F85J10     PIC18F85J11     PIC18F85J15     PIC18F85J50
PIC18F85J90     PIC18F85J94     PIC18F85K22     PIC18F85K90
PIC18F8620
PIC18F8621      PIC18F8622
PIC18F8627      PIC18F8628      PIC18F8680      PIC18F86J10
PIC18F86J11     PIC18F86J15     PIC18F86J16     PIC18F86J50
PIC18F86J55     PIC18F86J60     PIC18F86J65     PIC18F86J72
PIC18F86J90     PIC18F86J93     PIC18F86J94     PIC18F86K22
PIC18F86K90     PIC18F86J99
PIC18F8720      PIC18F8722      PIC18F8723      PIC18F87J10
PIC18F87J11     PIC18F87J50     PIC18F87J60     PIC18F87J72
PIC18F87J90     PIC18F87J93     PIC18F87J94     PIC18F87K22
PIC18F87K90     PIC18F95J94     PIC18F96J60     PIC18F96J65
PIC18F96J94     PIC18F96J99     PIC18F97J60     PIC18F97J94

PIC18LF13K22    PIC18LF13K50    PIC18LF14K22    PIC18LF14K50
PIC18LF23K22    PIC18LF24J10    PIC18LF24J11    PIC18LF24J50
PIC18LF24K22    PIC18LF24K50    PIC18LF25J10
PIC18LF25J11    PIC18LF25J50    PIC18LF25K22    PIC18LF25K50
PIC18LF25K80
PIC18LF26J11    PIC18LF26J13    PIC18LF26J50    PIC18LF26J53
PIC18LF26K22    PIC18LF26K80
PIC18LF27J13    PIC18LF27J53    PIC18LF43K22    PIC18LF44J10
PIC18LF44J11    PIC18LF44J50    PIC18LF44K22    PIC18LF45J10
PIC18LF45J11    PIC18LF45J50
PIC18LF45K22    PIC18LF45K50    PIC18LF45K80    PIC18LF46J11
PIC18LF46J13    PIC18LF46J50    PIC18LF46J53    PIC18LF46K22
PIC18LF45K80    PIC18LF47J13    PIC18LF47J53
PIC18LF65K80    PIC18LF66K80
PICMCV20USB
</pre><p>

*<b>Note</b>: Early adopter support has been added for these devices since
        last release</p><p>

+<b>Note</b>: These devices DO NOT have peripheral library support.</p>
<!--
Syntax for commented out lines
-->


        <p>THE PARTS LISTED ABOVE MAY NOT ALL BE COMMERCIALLY AVAILABLE.</p>
</span>

<LI class="Heading0"><h1><A NAME="Documentation">
        MPLAB C Compiler for PIC18 MCUs Documentation</A></h1>
<span style="font-size:10pt;font-weight:normal;">

        <p>The following files are associated with this release and can
        be found in the &lt;install_dir&gt;\doc directory.:</p>
<UL>

        <LI>MPLAB C18 C Compiler Getting Started (PDF)</LI>
        <LI>PIC18 Configuration Settings Help (hlpPIC18ConfigSet.chm)</LI>
        <LI>COFF File Format Help (hlpCOFFfile.chm)</LI>
        <LI>MPLAB C18 C Compiler User's Guide Help (hlpC18ug.chm)</LI>
        <LI>MPLAB C18 C Compiler Libraries (hlpC18Lib.chm)</LI>
        <LI>Hardware Peripheral Library Function Documention found under the
        &lt;install_dir&gt;\doc\periph_lib directory.</LI>
</UL>
        <p>Documentation (in pdf format) is available from our web site:
        <A HREF="http://www.microchip.com/c18">http://www.microchip.com/c18</A>
        however:</p>
<UL>
        <LI>The information in the MPLAB C18 C Compiler User's Guide Help
        (hlpC18ug.chm) supersedes the information found in the MPLAB C18 C
        Compiler User's Guide (PDF) (DS51288 revision J) which can be found
        on the web site.</LI>

        <LI>The information in the MPLAB C18 C Compiler Libraries
        (hlpC18Lib.chm) and the Hardware Peripheral Library Function
        Documentation found under the &lt;install_dir&gt;\doc\periph_lib
        directory supersede the information found in the MPLAB C18 C Compiler
        Libraries (PDF) (DS51297 revision F) which can be found on the web
        site.</LI>
</UL>
</span>



<LI class="Heading0"><h1><A NAME="Installation and Upgrades">
        Installation and Upgrades</A></h1>
<span style="font-size:10pt;font-weight:normal;">

        <p>MPLAB C Compiler for PIC18 MCUs requires the use of MPLINK Linker;
        MPLAB C18 v3.00 or
        later will require MPLINK Linker v4.00 or later.  The latest version
        of MPLINK Linker is included with the installation. </p>

        <p>To verify correct installation of MPLAB C Compiler for PIC18 MCUs,
        execute the batch file
        &lt;install_dir&gt;\example\an696\buildit.bat. If the compiler system
        has been installed correctly, the file 18motor.out will be created.
</p>
        <p>When installing MPLAB C Compiler for PIC18 MCUs, the setup program
        offers the user the
        ability to change several environment settings. The following
        options are provided:
</p>
        <p><b>Environment Variables:</b>
</p>
<UL>
        <LI>Add MPLAB C18 to PATH environment variable<br />
        The directory of the compiler executables is added to the
        beginning of the current PATH environment variable.
</LI>
        <LI>Add MPASM Assembler to PATH environment variable<br />
        The directory of the MPASM Assembler executable is added to the
        beginning of the current PATH environment variable.
</LI>
        <LI>Add header file path to MCC_INCLUDE environment variable<br />
        The location of the header (.h) files is added to the beginning
        of the user's MCC_INCLUDE environment variable. MPLAB C18 uses
        this setting to search for header files.
</LI>
        <LI>Modify PATH and MCC_INCLUDE variables for all users<br />
        The options listed above are applied to the machine environment
        variables instead of the user environment variables, so that
        they affect all users and not just the current user.<br />This option
        only appears if the user running the installer has administrative
        rights.
</LI>
</UL>
        <p><b>MPLAB IDE Configuration:</b><br />
        The options below only appear if the user has a version of MPLAB IDE
        installed. </p>
<UL>
        <LI>Update MPLAB IDE to use this MPLAB C18<br />
        Configuration settings used by the MPLAB IDE to find MPLAB C18
        will be updated to indicate the location of this release.
</LI>
        <LI>Update MPLAB IDE to use this MPLINK Linker, MPLIB librarian, and
        MPASM Assembler<br />
        Settings used by MPLAB IDE to find the MPLINK Linker, MPLIB
        librarian, and MPASM Assembler will be updated to point to those
        in this release.
</LI>
        <LI>Update MPLAB IDE Help with MPLAB C18 documentation <br />
        Documentation installed with MPLAB C18 will be made available from
        the Help menu of the MPLAB IDE.<br />
        This option only appears if documentation is being installed.
</LI>
        <LI>Perform MPLAB IDE updates for all users<br />
        The changes to the MPLAB IDE configuration are applied to the
        machine registry instead of that of the current user, so that
        they affect all users and not just the current user.<br />
        This option only appears if the user running the installer has
        administrative rights.
</UL>
        <p>If MPLAB C18 is uninstalled, these changes to the IDE configuration
        will not be rolled back. <br /></p>

        <p>If you have previously installed a Student, Demo, or Lite version
        of MPLAB C18 and you wish to upgrade your current installation, simply
        purchase and install the full Standard version - it will overwrite the
        other version. So, no license key is required.</p>
</span>

<LI class="Heading0"><h1><A NAME="IDE">Using MPLAB C Compiler for PIC18 MCUs
        with the MPLAB IDE</A></h1>
<span style="font-size:10pt;font-weight:normal;">

        <p>See the document "MPLAB C18 C Compiler Getting Started Guide" for a
        step-by-step tutorial on using MPLAB C Compiler for PIC18 MCUs with
        the MPLAB IDE.</p>

        <p>The current documentation is available from our web site,
        <A HREF="http://www.microchip.com/c18">http://www.microchip.com/c18</A>
        </p>

        <p><b>NOTE</b>: MPLAB C18 v3.00 and later will not be compatible with
        versions of the MPLAB IDE prior to v7.21. </p>
</span>

<LI class="Heading0"><h1><A NAME="KnownProblems">Known Problems</A></h1>
<span style="font-size:10pt;font-weight:normal;">

        <p>The following are some of the known issues with MPLAB C18 v3.21.
        The first list presented, <A HREF="#SSRSUMMARY" TITLE="Jump to SSR
        Summary">SSR SUMMARY</A>, is a brief summary of each SSR, System
        Service Request, for ease of reference. For more details on an SSR,
        see that SSR in the list <A HREF="#SSRDETAILS" TITLE="Jump to SSR
        Details">SSR DETAILS</A> which follows.
</p>
<h2><u><A NAME="SSRSUMMARY">SSR SUMMARY</A></u></h2>
<h2>General</h2><br />
<DL>

<DT>(<A HREF="#SSR18487" TITLE="Detailed description of SSR 18487">
        <b>C18-19 / 18487</b></A>)</DT><DD>With the compound assignment
        operators, the usual type conversions which are to be performed on
        the operands are not done correctly when the left operand is 8 bits
        in size.

<DT>(<A HREF="#SSR20189" TITLE="Detailed description of SSR 20189">
        <b>C18-39 / 20189</b></A>)</DT><DD>(non-extended mode only) Passing a
        static parameter to a function pointer in a structure should generate
        an error message, but instead generates an internal compiler error.

<DT>(<A HREF="#SSR20359" TITLE="Detailed description of SSR 20359">
        <b>C18-40 / 20359</b></A>)</DT><DD>There is a bug in the implementation
        of the scoping of typedef names.

<DT>(<A HREF="#SSR20975" TITLE="Detailed description of SSR 20975">
        <b>C18-45 / 20975</b></A>)</DT><DD>With integer promotions enabled,
        if the left operand of the &gt;&gt;= operator is negative, the result
        stored in the operand is incorrect.

<DT>(<A HREF="#SSR21192" TITLE="Detailed description of SSR 21192">
        <b>C18-50 / 21192</b></A>)</DT><DD>(non-extended mode only) The result
        of the %= operator where the left operand is a 24-bit or 32-bit rom
        variable is incorrect.

<DT>(<A HREF="#SSR21261" TITLE="Detailed description of SSR 21261">
        <b>C18-53 / 21261</b></A>)</DT><DD>(non-extended mode only) Calling a
        function pointer which has been converted from an object pointer
        generates an internal compiler error.

<DT>(<A HREF="#SSR21514" TITLE="Detailed description of SSR 21514 / 22953">
        <b>C18-64 / 21514</b></A>)</DT><DD>(non-extended mode only) Using
        static parameters with a function which has a variable number of
        arguments is not supported, but does not generate a compile time error.

<DT>(<A HREF="#SSR21634" TITLE="Detailed description of SSR 21634 / 23024">
        <b>C18-74 / 21634</b></A>)</DT><DD>The assignment of the address of an
        object in constant program memory to a pointer to non-constant data
        memory does not generate a diagnostic.

<DT>(<A HREF="#SSR21693" TITLE="Detailed description of SSR 21693">
        <b>C18-80 / 21693</b></A>)</DT><DD>Redefinitions of structure tags in
        nested scopes are not observed properly by MPLAB C18.

<DT>(<A HREF="#SSR22091" TITLE="Detailed description of SSR 22091">
        <b>C18-88 / 22091</b></A>)</DT><DD>String literals are placed in
        program memory and so must be assigned to variables of type
        'rom char *'. However, assigning one to a pointer to data memory
        does not generate a diagnostic.

<DT>(<A HREF="#SSR22147" TITLE="Detailed description of SSR 22147">
        <b>C18-89 / 22147</b></A>)</DT><DD>Octal constants which contain an
        '8' or '9' do not generate a diagnostic. Instead, the code compiles
        quietly, and the value used for the constant is indeterminate.

<DT>(<A HREF="#SSR22768" TITLE="Detailed description of SSR 22768">
        <b>C18-106 / 22768</b></A>)</DT><DD>The redeclaration of a structure
        tag should generate an error, but does not.

<DT>(<A HREF="#SSR23183" TITLE="Detailed description of SSR 23183">
        <b>C18-115 / 23183</b></A>)</DT><DD>When the conditional (?:) operator
        is used with operands which are greater than 32 bits in size, an
        "irreducible tree" internal error may be generated.

<DT>(<A HREF="#SSR23897" TITLE="Detailed description of SSR 23897">
        <b>C18-126 / 23897</b></A>)</DT><DD>integer *= float-constant casts
        constant to integer before multiplication.

<DT>(<A HREF="#SSR24130" TITLE="Detailed description of SSR 24130">
        <b>C18-130 / 24130</b></A>)</DT><DD>A conflicting redefinition of type
        does not cause error or warning.

<DT>(<A HREF="#SSR24481" TITLE="Detailed description of SSR 24481">
        <b>C18-140 / 24481</b></A>)</DT><DD>Due to a COFF limitation, a greater
        than 16-bit relocation offset is calculated incorrectly at link-time.

<DT>(<A HREF="#SSR26056" TITLE="Detailed description of SSR 26056">
        <b>C18-166 / 26056</b></A>)</DT><DD>Unable to reduce tree for:
        if (local char * &gt; parameter const rom far char * + constant)

<DT>(<A HREF="#SSR27011" TITLE="Detailed description of SSR 27011">
        <b>C18-183 / 27011</b></A>)</DT><DD>No error message generated for
        run time assignment to a const struct.

<DT>(<A HREF="#SSR27455" TITLE="Detailed description of SSR 27455">
        <b>C18-188 / 27455</b></A>)</DT><DD>The volatile qualifier is not
        applied to struct members.

<DT>(<A HREF="#SSRC18281" TITLE="Detailed description of SSR C18-281">
        <b>C18-281</b></A>)</DT><DD>Conditional expression involving
        bitfield arithmetic evaluated incorrectly.

<DT>(<A HREF="#SSRC18285" TITLE="Detailed description of SSR C18-285">
        <b>C18-285</b></A>)</DT><DD>Type-qualifier mismatch warning building
        vfprintf.c for small memory model.

<DT>(<A HREF="#SSRC18286" TITLE="Detailed description of SSR C18-286">
        <b>C18-286</b></A>)</DT><DD>No qualifier-mismatch warning assigning
        address of const to non-const pointer.

<DT>(<A HREF="#SSRC18289" TITLE="Detailed description of SSR C18-289">
        <b>C18-289</b></A>)</DT><DD>assertion on passing arguments to function
        pointer in static/overlay model.

<DT>(<A HREF="#SSR22483" TITLE="Detailed description of SSR 22483">
        <b>BIN18-3 / 22483</b></A>)</DT><DD>MPLIB librarian is unable to work
        with MPLAB C18 files compiled in the static overlay model.
</DL>

<h2>Inline Assembly</h2><br />
<DL>

<DT>(<A HREF="#SSR22170" TITLE="Detailed description of SSR 22170 / 22632">
        <b>C18-90 / 22170</b></A>)</DT><DD>Incorrect use of automatic local
        variables in inline assembly code does not generate a warning or error.

<DT>(<A HREF="#SSR22559" TITLE="Detailed description of SSR 22559">
        <b>C18-96 / 22559</b></A>)</DT><DD>Enumeration constants in expressions
        which are operands of inline assembly instructions can cause an
        internal error to be generated.
</DL>

<h2>Preprocessor</h2><br />
<DL>

<DT>(<A HREF="#SSR21252" TITLE="Detailed description of SSR 21252 / 25868">
        <b>C18-51 / 21252 / C18-160 / 25868</b></A>)</DT><DD>A macro invocation
        spanning more than one logical source file line may throw off line
        number information or cause the preprocessor to not output a line
        number, causing debugging difficulty in the MPLAB IDE.

<DT>(<A HREF="#SSR21817" TITLE="Detailed description of SSR 21817">
        <b>C18-81 / 21817</b></A>)</DT><DD>Preprocessor merging operator should
        take precedence over the stringization operator.

<DT>(<A HREF="#SSR22522" TITLE="Detailed description of SSR 22522">
        <b>C18-92 / 22522</b></A>)</DT><DD>The preprocessor may go into an
        infinite loop when expanding mutually recursive macros.

<DT>(<A HREF="#SSR23717" TITLE="Detailed description of SSR 23717">
        <b>C18-122 / 23717</b></A>)</DT><DD>Comments in a macro call
        may cause incorrect substitution or a syntax error.

<DT>(<A HREF="#SSR23817" TITLE="Detailed description of SSR 23817">
        <b>C18-124 / 23817</b></A>)</DT><DD>The preprocessor performs macro
        replacement within the text of a #error directive.

<DT>(<A HREF="#SSR23827" TITLE="Detailed description of SSR 23827">
        <b>C18-125 / 23827</b></A>)</DT><DD>Crash (after error message) for
        #elif with no preceding #if

<DT>(<A HREF="#SSR24038" TITLE="Detailed description of SSR 24038">
        <b>C18-128 / 24038</b></A>)</DT><DD>No error when #if does not have
        corresponding #endif and condition is true.

<DT>(<A HREF="#SSR25409" TITLE="Detailed description of SSR 25409">
        <b>C18-154 / 25409</b></A>)</DT><DD>Preprocessor evaluates expressions
        in discarded lines of an #ifdef expression.

<DT>(<A HREF="#SSR26385" TITLE="Detailed description of SSR 26385">
        <b>C18-169 / 26385</b></A>)</DT><DD>The preprocessor does not throw an
        error on finding "#elsif"

<DT>(<A HREF="#SSR27540" TITLE="Detailed description of SSR 27540">
        <b>C18-193 / 27540</b></A>)</DT><DD>A malformed expression in a #if
        preprocessor directive on the last line of a file with no terminating
        end of line character may cause the preprocessor to crash.

<DT>(<A HREF="#SSR28101" TITLE="Detailed description of SSR 28101">
        <b>C18-204 / 28101</b></A>)</DT><DD>Circular or recursive macro
        definitions can cause the preprocessor to take up all available CPU
        cycles and hang for a long time before giving an error.
</DL>

<h2>Libraries</h2>
<b>Note</b>: See <A HREF="#Devices" TITLE="Jump to 'Devices Supported'
        Section">"Devices Supported"</A> for the Note that shows which devices
        DO NOT have peripheral library support.<br /><br />
<DL>

<DT>(<A HREF="#SSR18624" TITLE="Detailed description of SSR 18624">
        <b>C18-23 / 18624</b></A>)</DT><DD>The library routine 'atof' generates
         a result less precise than simply assigning a constant.

</DL>

<h2>Header Files</h2><br />
<DL>

<DT>None.
</DL>

<h2>User Error Screening</h2><br />
<DL>

<DT>None.
</DL>

<h2><u><A NAME="SSRDETAILS">SSR DETAILS</A></u></h2>
<h2>General</h2><br />
<DL>

<DT>(<A NAME="SSR18487"><b>C18-19 / 18487</b></A>)<br />
        With the compound assignment operators, the usual type conversions
        which are to be performed on the operands are not done correctly when
        the left operand is 8 bits in size. This can cause problems in these
        instances:<br />
<br />
        -- With integer promotions enabled, the compound assignment division
        operator may return incorrect results on 8-bit operands when the left
        operand is signed and the right is unsigned. The workaround is to
        replace:<br />
<pre>
  signed char x;
  unsigned char y;
  ...
  x /= y;
</pre>
        with:<br />
<pre>
  signed char x;
  unsigned char y;
  ...
  x = x / y;
</pre>
        -- The compound assignment remainder operator may return incorrect
        results when the right operand is greater than 8 bits in size. The
        workaround is to replace<br />
<pre>
  unsigned char x;
  unsigned short y;
  ...
  x %= y;
</pre>
        with:<br />
<pre>
  unsigned char x;
  unsigned short y;
  ...
  x = x % y;
</pre>

<DT>(<A NAME="SSR20189"><b>C18-39 / 20189</b></A>)
        (non-extended mode only)<br />
        Passing a static parameter to a function pointer in a structure should
        generate an error message, but instead generates an internal compiler
        error.<br />
        For example:<br />
<pre>
  struct { void (*f) (static int x); } S;
  void main (void) { S.f (1); }
</pre>

<DT>(<A NAME="SSR20359"><b>C18-40 / 20359</b></A>)<br />
        There is a bug in the implementation of the scoping of typedef
        names.<br />
        The following example generates a syntax error:<br />
<pre>
  void main (void)
  {
    typedef int X;
    {
      struct Y { int X; };
      (X)3; /* this should refer to the typedef name,
             * not the structure member */
    }
  }
</pre>
        The textually intervening declaration of 'X' as a structure member
        causes the typedef declaration of 'X' to be lost.<br />
<br />

<DT>(<A NAME="SSR20975"><b>C18-45 / 20975</b></A>)<br />
        With integer promotions enabled, if the left operand of the
        &gt;&gt;= operator is negative, the result stored in the operand
        is incorrect.  <br />
        For example, 'x' should be end up with -1, but instead ends up
        with 1: <br />
<pre>
  signed char x;
  x = 0x80;
  x >>= 7; /* 'x' should be -1, but is 1 instead */
</pre>
        The integer promotions are not performed on 'x'.<br />
<br />

<DT>(<A NAME="SSR21192"><b>C18-50 / 21192</b></A>)
        (non-extended mode only)<br />
        The result of the %= operator where the left operand is a 24-bit or
        32-bit rom variable is incorrect. For example:<br />
<pre>
  rom short long x;
  void main (void)
  {
    short long y;
    x = 1025;
    y = x %= 2; /* 'x' correctly receives 1, but 'y' does not */
    ...
</pre>

<DT>(<A NAME="SSR21261"><b>C18-53 / 21261</b></A>)
        (non-extended mode only)<br />
        Calling a function pointer which has been converted from an object
        pointer generates an internal compiler error. For example:<br />
<pre>
  unsigned long x[4];
  void main (void) { ((void (*)(void))x)( ); }
</pre>

<DT>(<A NAME="SSR21514"><b>C18-64 / 21514</b></A>)
        (non-extended mode only)<br />
        Using static parameters with a function which has a variable number of
        arguments is not supported, but does not generate a compile time
        error. Instead, a link time error is emitted which may not be
        comprehensible:<br />
<pre>
  Error - could not find definition of symbol '_foo:101' ...
</pre>
        Such would be the error message if the function in question is called
        'foo'.<br />
<br />

<DT>(<A NAME="SSR21634"><b>C18-74 / 21634</b></A>)<br />
        The assignment of the address of an object in constant program memory
        to a pointer to non-constant data memory does not generate a
        diagnostic. For example:<br />
<pre>
  const rom char x;
  char *p;
  void main (void) { p = &x; ... }
</pre>
        A diagnostic should be generated. The effect of referencing through
        'p' following the assignment is indeterminate.<br />
<br />

<DT>(<A NAME="SSR21693"><b>C18-80 / 21693</b></A>)<br />
        Redefinitions of structure tags in nested scopes are not observed
        properly by MPLAB C18. For example:<br />
<pre>
  struct s { int x; } S;
  void main (void)
  {
    struct s; /* this introduces a new type, hiding the previous */
    struct s *Sp = &S; /* this is an incompatible assignment */
    Sp->x++;  /* invalid access of an incomplete type */
    ...
</pre>
        The inner declaration of 'struct s' introduces a new (incomplete) type,
        which is different than the first 'struct s'. However, the above
        program compiles quietly. The structure tag is not redefined.<br />
<br />


<DT>(<A NAME="SSR22091"><b>C18-88 / 22091</b></A>)<br />
        String literals are placed in program memory and so must be assigned
        to variables of type 'rom char *'. However, assigning one to a
        pointer to data memory does not generate a diagnostic.
        For example:<br />
<pre>
  char *s = "hello world";
</pre>
        Any references through 's' will result in indeterminate behavior.<br />
<br />

<DT>(<A NAME="SSR22147"><b>C18-89 / 22147</b></A>)<br />
        Octal constants which contain an '8' or '9' do not generate a
        diagnostic. Instead, the code compiles quietly, and the value used
        for the constant is indeterminate.<br />
<br />

<DT>(<A NAME="SSR22768"><b>C18-106 / 22768</b></A>)<br />
        The redeclaration of a structure tag should generate an error, but
        does not. For example:<br />
<pre>
  struct foo { int a; };
  struct foo { char b; };

  struct foo F;
</pre>
        compiles quietly without error. The variable 'F' takes on the type of
        the second declaration.<br />
<br />

<DT>(<A NAME="SSR23183"><b>C18-115 / 23183</b></A>)<br />
        When the conditional (?:) operator is used with operands which are
        greater than 32 bits in size, an "irreducible tree" internal error may
        be generated. For example:<br />
<pre>
  struct s
  {
    unsigned long x;
    char y;
  } S, T;

  void main (void)
  {
    char b;
    unsigned long z;

    ...
    z = (b ? S : T).x;
    ...
</pre>
        generates such an error. The workaround is to use an 'if' statement
        instead of the conditional operator.<br />
<br />

<DT>(<A NAME="SSR23897"><b>C18-126 / 23897</b></A>)<br />
        integer *= float-constant casts constant to integer before
        multiplication.<br />
        For example:<br />
<pre>
  volatile unsigned char uc_test;
  uc_test = 80;
  uc_test *= 0.7; /* Expected: 56, Actual: 0*/
</pre>
        A workaround to this is to write the last statement as:<br />
<pre>
  uc_test = uc_test * 0.7;
</pre>

<DT>(<A NAME="SSR24130"><b>C18-130 / 24130</b></A>)<br />
        Conflicting redefinition of type does not cause error or warning.<br />
        For example:<br />
<pre>
  typedef unsigned short long foo;
  typedef unsigned char foo;
  typedef unsigned short foo;
  typedef unsigned int foo;
  typedef unsigned long foo;
  typedef double foo;
  typedef long double foo;
  typedef struct
  {
    ...
  } foo;
  typedef union foo
  {
    ...
  } foo;
</pre>
        It should cause the compiler to emit errors such as:<br />
<pre>
  test.c:3: error: conflicting types for `foo'
  test.c:2: error: previous declaration of `foo'
</pre>

<DT>(<A NAME="SSR24481"><b>C18-140 / 24481</b></A>)<br />
        Due to a COFF limitation, a greater than 16-bit relocation offset is
        calculated incorrectly at link-time.<br />
<br />
        Microchip's Common Object File Format (COFF) contains a limitation
        in the relocation entry, which is the structure that implements the
        dynamics of relocation. In Microchip's COFF, the offset to add to the
        base address of the symbol is stored in the relocation entry. This
        differs from the System V relocation data in which the offset is
        stored in the location being relocated to. This difference is
        necessary because Microchip relocations are not restricted to just
        filling in an address + offset value into the data stream, but also
        to do simple code modifications. The limitation comes from the fact
        that this offset is defined as a short, which dictates that offsets
        may be no larger than 16-bit.<br />
        The following example shows the side effect of this limitation:<br />
<pre>
  #pragma romdata constscn=0x2000
  rom const unsigned char var;
  #pragma romdata

  rom const unsigned char *varptr = &var + 0x8000;
</pre>
        The above code gives the following relocation entries:<br />
<pre>
 Relocation: r_vaddr=0x00000000, r_symndx=2, r_offset=-32768, r_type=4
 Relocation: r_vaddr=0x00000001, r_symndx=2, r_offset=-32768, r_type=3
 Relocation: r_vaddr=0x00000002, r_symndx=2, r_offset=-32768, r_type=21
</pre>
        Note that the r_offset field reflects an offset of -32k instead of +32k.<br />
<br />
        A workaround is to use code for which the compiler will evaluate
        the offset at run-time.<br />
        For example:<br />
<pre>
  void foo( void )
  {
    varptr = &var;
    varptr += 0x8000;
  }
</pre>

<DT>(<A NAME="SSR26056"><b>C18-166 / 26056</b></A>)<br />
        Unable to reduce tree for if (local char * &gt; parameter const rom
        far char * + constant)<br />
<br />
        For both extended and non-extended modes, the following function:<br />
<pre>
  void foo(const rom far char * FullPath, char *Path, char *FileName)
  {
    char *NameStart;
    char *s;

    if ((NameStart > FullPath + 1) && (*(Path - 1) == '\\'))
      return;
  }
</pre>
        results in:
<pre>
  Fatal [100] - internal - unable to reduce tree
</pre>
        The problem is caused by comparing the address of a pointer located
        on the stack (i.e. ram) with one located in rom. This is not a valid
        comparison and should result in an error.<br />
<br />

<DT>(<A NAME="SSR27011"><b>C18-183 / 27011</b></A>)<br />
        No error message generated for run time assignment to a const
        struct.<br />
        For example, the code:<br />
<pre>
  typedef struct
  {
          int b;
  } typeB;

  const typeB objB;

  void fB_type( )
  {
          objB.b = 1;
  }
</pre>
        does not generate an error.<br />
<br />

<DT>(<A NAME="SSR27455"><b>C18-188 / 27455</b></A>)<br />
        The volatile qualifier is not applied to struct members.<br />
        For the following source code:
<pre>
  struct
    {
      unsigned char aaa;
      volatile unsigned char bbb;
    } flags;
</pre>
        the volatile qualifier on the second member of the struct 'flags'
        is ignored.<br />
<br />
        Workaround:<br />
        Apply the volatile qualifier to the entire struct.<br />
<pre>
  struct
    {
      unsigned char aaa;
      volatile unsigned char bbb;
    } volatile flags;
</pre>

<DT>(<A NAME="SSRC18281"><b>C18-281</b></A>)<br />
        Conditional expression involving bitfield arithmetic evaluated
        incorrectly.<br /><br />
For the following source code

<pre>
struct {
 unsigned	b1:1;
 unsigned	b2:1;
 unsigned	b3:1;
 unsigned	b4:1;
} Test;

char Signal (void)
{
 while(1);
 return 1;
}

volatile unsigned char testval;
void main (void)
{
 Test.b1 = 1;
 Test.b2 = 1;
 Test.b3 = 1;
 Test.b4 = 1;

 testval = Test.b1 + Test.b2 + Test.b3;

 /* Expected false, Actual true */
 if (Test.b1 + Test.b2 + Test.b3 == 1)   /* line 26 */
 Signal();

 /* Expected false, Actual false */
 if (Test.b1 + Test.b2 + Test.b3  == 2)
 Signal();

 /* Expected false, Actual false */
 if (!(Test.b1 + Test.b2  + Test.b3  - 1))
 Signal();

 while(1);
}
</pre>
the first 'if' statement incorrectly evaluates to TRUE.
The related generated code is

<pre>
mcc18 -s test.c -O-
...
  43(  26): movlb high( Test )
  44(  26): movf Test, 0, 1
  45(  26): andlw 1
  46(  26): addwf __tmp_0, 0, 0
  47(  26): addwf __tmp_0 + 1, 0, 0
  48(  26): bz 1                             //  <--- Why compare with zero?
  49(  26): rcall Signal, 0
</pre>
The workaround for this SSR is to cast the left hand side of the comparison
to (unsigned char) as following
<pre>
  if ((unsigned char) Test.b1 + Test.b2 + Test.b3 == 1)   /* line 26 */

  signal()
</pre>


<DT>(<A NAME="SSRC18285"><b>C18-285</b></A>)<br />
        Type-qualifier mismatch warning building vfprintf.c for small memory
        model.<br />
1) Update the batch files to use -ms and _SMALL_.<br />
2) Update the header files to define MEM_MODEL near.<br />
3) Run makeall.bat.<br />
<pre>
BUILDING EXTENDED MODE LIBRARIES
Building startup modules...
Installing startup modules...
Building library modules...
...math module...
...standard C library module...
C:\MCC18\src\extended\stdclib\vfprintf.c:268:Warning [2066] type qualifier mismatch in assignment
...delay module...
Installing library...
</pre>

The code shows<br /><br />

string.h
<pre>
/* Change this to near (or omit altogether) if building small memory model
 * versions of the libraries
 */
#define MEM_MODEL near

/** @name strlenpgm
 * The {\bf strlenpgm} function performs a {\bf strlen} where {\bf s}
 * points to program memory.
 * @param s pointer to object in program memory
 */
sizerom_t strlenpgm (auto const MEM_MODEL rom char *s);
</pre>
vfprintf.c
<pre>
int
vfprintf (auto FILE *handle, auto const rom char *f, auto va_list ap)
{
  unsigned char c;
  int count = 0;

  for (c = *f; c; c = *++f)
    {
      if (c == '%')
        {
          unsigned char flags = 0;
          unsigned char width = 0;
          unsigned char precision = 0;
          unsigned char have_precision = 0;
          unsigned char size = 0;
          unsigned char space_cnt;
          unsigned char cval;
          unsigned long larg;
          far rom char *romstring;

/* ... Removed code ... */

            case 'S':
              if (size == _FMT_SHLONG)
                romstring = va_arg (ap, rom far char *);
              else
                romstring = (far rom char*)va_arg (ap, rom near char *);
              n = strlenpgm (romstring);                      /* line 268 */
</pre>
Passing a far pointer to a function expecting a near pointer should be ok, but our library should really build without warnings.
<br /><br />
<DT>(<A NAME="SSRC18286"><b>C18-286</b></A>)<br />
        No qualifier-mismatch warning assigning address of const to non-const
        pointer.<br /><br />

        For the following source code
<pre>
char* pdromU8;
const char cdromU8;

void funct (void)
{
  pdromU8 = &cdromU8;   /* Expect warning */
}
</pre>

        the compiler should emit a qualifier-mismatch warning because the
        'const' is lost.<br /><br />


<DT>(<A NAME="SSRC18289"><b>C18-289</b></A>)<br />
        Assertion on passing arguments to function pointer in static/overlay
        model.<br /><br />

        This only happens in traditional mode.<br /><br />
        When a function pointer is declared in typedef struct without
        explicitly declaring its arguments as auto, at compile time with
        -scs or -sco, the compiler asserts failier on the line that the
        function pointer is called.<br /><br />

        The problem is that compiler should send diagnostic at the place of
        declaration of function pointer when -scs or -sco are used, to tell
        the user that they must declare the arguments explicitly as auto.
        <br /><br />

<DT>(<A NAME="SSR22483"><b>BIN18-3 / 22483</b></A>)<br />
        MPLIB librarian is unable to work with MPLAB C18 files compiled in
        the static overlay model.<br />
        For example:
<pre>
  int add( int a, int b )
  {
    int c;
    c = a + b;
    return c;
  }
</pre>
        Compiled with:
<pre>
  mcc18 test.c -sco
</pre>
        Then placed in an archive containing only this file:
<pre>
  mplib -c test.lib test.o
</pre>
        MPLIB librarian is unable to list the files in the archive.
<pre>
  mplib -t test.lib
</pre>
        Gives the error:
<pre>
  Error - Coff file 'test.o' could not read string table.
  Error - Could not build member 'test.o' in library file 'test.lib'.
</pre>
        Trying to use such an archive with MPLINK Linker also gives an error
        saying it could not read the string table.<br />
<br />
<br />
</DL>
<h2>Inline Assembly</h2><br />
<DL>

<DT>(<A NAME="SSR22170"><b>C18-90 / 22170</b></A>)<br />
        Incorrect use of automatic local variables in inline assembly code
        does not generate a warning or error.<br />
        Automatic local variables, when used in inline assembly expressions,
        are given a value which is their offset from the frame pointer.<br />
        For example, the following code demonstrates the proper accessing
        of stack-based variable 'a' using its value in PLUSW2 addressing.<br />
        It then demonstrates improper accessing of stack variable 'b' by
        attempting to reference it using direct mode addressing.<br />
<pre>
  #include &lt;p18f452.h&gt;

  void assignlocals( void )
  {
    auto char a, b;

    _asm

    // correctly assigns TMR0L to variable 'a'
    movlw a
    movff TMR0L, PLUSW2

    // DOES NOT correctly assign TMR0L to variable 'b'
    movff TMR0L, b

    _endasm
  }
</pre>
        The compiler should give an error (or at least a warning) on the use
        of variable 'b' in a direct mode addressing instruction, but it instead
        generates code as if the offset were an absolute address.<br />
<br />

<DT>(<A NAME="SSR22559"><b>C18-96 / 22559</b></A>)<br />
        Enumeration constants in expressions which are operands of inline
        assembly instructions can cause an internal error to be generated.<br />
        The workaround is to use integer constants instead.<br />
<br />
</DL>
<h2>Preprocessor</h2><br />
<DL>

<DT>(<A NAME="SSR21252"><b>C18-51 / 21252 / C18-160 / 25868</b></A>)<br />
        A macro invocation spanning more than one logical source file line
        may throw off line number information, or cause the preprocessor to
        not output a line number, causing debugging difficulty in the MPLAB
        IDE.<br />
        For example:<br />
<pre>
  void main (void)
  {
    int x;

    f (arg1,
       arg2,
       arg3); // macro call
    ...
    x++;      // breakpoint may not function correctly here
    ...
</pre>
        A breakpoint set on a line following such a macro call may not work
        correctly. MPLAB IDE may state that such a breakpoint cannot be
        set.<br />
        Additionally, stepping through the source code may not follow the
        expected sequence of execution. The workaround is to use the line
        splice character after each macro argument:<br />
<pre>
  void main (void)
  {
    int x;

    f (arg1,\
       arg2,\
       arg3);
    ...
    x++;
</pre>

<DT>(<A NAME="SSR21817"><b>C18-81 / 21817</b></A>)<br />
        Preprocessor merging operator should take precedence over
        the stringization operator.<br />
        For example:
<pre>
  #define STR(a) NXSTR(a)
  #define NXSTR(a) #a

  void
  foo (void)
  {
    // Apply "merging" operator
     #define CAT(a, b) NXCAT(a, b)
     #define NXCAT(a, b) a ## b

    // The two tokens '1.' and 'E9' should be merged into a single token
    // before the stringization operator is applied.
     STR(CAT (1., E9));
  }
</pre>
        Preprocesses to:<br />
<pre>
  "CAT (1., E9)" ;
</pre>
        but it should produce:<br />
<pre>
  "1.E9" ;
</pre>

<DT>(<A NAME="SSR22522"><b>C18-92 / 22522</b></A>)<br />
        The preprocessor may go into an infinite loop when expanding mutually
        recursive macros.<br />
        For example:<br />
<pre>
  #define x (4 + y)
  #define y (2 * x)
  void main (void) { y; }
</pre>
        causes the preprocessor to run indefinitely.<br />
<br />

<DT>(<A NAME="SSR23717"><b>C18-122 / 23717</b></A>)<br />
        Comments in a macro call may cause incorrect substitution or a syntax
        error.<br />
        For example:<br />
<pre>
  #pragma romdata CONFIG
  _CONFIG_DECL (_OSCS_OFF_1H & _OSC_HSPLL_1H, // comments
  _PWRT_ON_2L & _BOR_OFF_2L & _BORV_42_2L,
  // comments
  0,
  _CCP2MUX_OFF_3H,
  ...
</pre>
        Another example:<br />
<br />
        A comment following the last argument in a macro invocation may cause
        a syntax error. For example:<br />
<pre>
  #include &lt;p18f8720.h&gt;
  #pragma romdata CONFIG
  _CONFIG_DECL
      (_CONFIG1H_DEFAULT,
       _CONFIG2L_DEFAULT,
       _CONFIG2H_DEFAULT,
       _CONFIG3L_DEFAULT,
       _CONFIG3H_DEFAULT,
       _CONFIG4L_DEFAULT,
       _CONFIG5L_DEFAULT,
       _CONFIG5H_DEFAULT,
       _CONFIG6L_DEFAULT,
       _CONFIG6H_DEFAULT,
       _CONFIG7L_DEFAULT,
       _CONFIG7H_DEFAULT //12
      );
  #pragma romdata
</pre>
        The workaround is to not have comments inside a macro call.<br />
<br />

<DT>(<A NAME="SSR23817"><b>C18-124 / 23817</b></A>)<br />
        The preprocessor performs macro replacement within the text of a
        #error directive.<br />
<br />
        Example source code:
<pre>
  #define FOSC 1800
  #error "FOSC is 1800"
</pre>
        Preprocessor command line:
<pre>
  cpp18 preproc-1.c
</pre>
        Preprocessor output:
<pre>
  #line 1 "preproc-1.c"
  #line 2 "preproc-1.c"
  preproc-1.c:2: "1800 is 1800"
</pre>

<DT>(<A NAME="SSR23827"><b>C18-125 / 23827</b></A>)<br />
        Crash (after error message) for #elif with no preceding #if
        For example:
<pre>
  ...
  /* no #if here */
  #elif defined (_FOO_)
  #endif
</pre>

<DT>(<A NAME="SSR24038"><b>C18-128 / 24038</b></A>)<br />
        No error is given when #if does not have corresponding #endif and the
        condition is true<br />
        For example:<br />
        This gives a syntax error:<br />
<pre>
  #if defined(x)
  int y = x;
</pre>
        But this does not:<br />
<pre>
  #define x 2
  #if defined(x)
  int y = x;
</pre>
        Both should give syntax errors since the #endif is missing.<br />
<br />

<DT>(<A NAME="SSR25409"><b>C18-154 / 25409</b></A>)<br />
        Preprocessor evaluates expressions in discarded lines of an #ifdef
        expression.<br />
        For example:<br />
<pre>
  #ifdef foo
  #if 12/foo
  #endif
  #endif
  ...
</pre>
        Will generate a divide by zero error from the preprocessor, but should
        not since the expression shouldn't be evaluated.<br />
<br />

<DT>(<A NAME="SSR26385"><b>C18-169 / 26385</b></A>)<br />
        The preprocessor does not throw an error on finding "#elsif"<br />
        The following code:
<pre>
  #define _BAR_

  #if defined(_FOO_)
    #error "_FOO_ defined"
  #elsif defined(_BAR_)
    #error "_BAR_ defined"
  #else
    #error "Neither defined"
  #endif
</pre>
        will print "Neither defined" since "#elsif" is not a valid preprocessor
        directive. Although it should be "#elif" no error or warning is given
        about the typo.<br />
<br />

<DT>(<A NAME="SSR27540"><b>C18-193 / 27540</b></A>)<br />
        A malformed expression in a #if preprocessor directive on the last line
        of a file with no terminating end of line character may cause the
        preprocessor to crash.<br />
        For example:
<pre>
  #define symbol
  #if symbol /* end of file */
</pre>
        causes the preprocessor to crash.<br />
<br />
        Workaround: Terminate the source file by adding a blank last line.<br />
        The preprocessor will display an error without crashing.<br />
<br />

<DT>(<A NAME="SSR28101"><b>C18-204 / 28101</b></A>)<br />
        Circular or recursive macro defnitions can cause the preprocessor to
        take up all available CPU cycles and hang for a long time before giving
        an error.<br />
        For example, the following code:
<pre>
  void main(void)
  {
    #define f g
    #define g f
    f(1);
  }
</pre>
        causes the preprocessor to hang for a long time, then give an error
        similar to:
<pre>
  Preprocessor Error : out of dynamic memory in yy_scan_buffer
</pre>


</DL>
<h2>Libraries</h2>
<b>Note</b>: See <A HREF="#Devices" TITLE="Jump to 'Devices Supported'
        Section">"Devices Supported"</A> for the Note that shows which devices
        have peripheral library support.<br /><br />
<DL>

<DT>(<A NAME="SSR18624"><b>C18-23 / 18624</b></A>)<br />
        The library routine 'atof' generates a result less precise than simply
        assigning a constant. For example:<br />
<pre>
  float a, c;
  char b[] = ".15625";
  void main ( )
  {
    a = atof (b);
    c = .15625;
  }
</pre>
        The representation of 'c' is 0x7c200000 and 'a' is 0x7c1fffff.<br />
<br />

</DL>

<h2>Header Files</h2><br />
<DL>

<DT>None.<br />
<br />

</DL>
<h2>User Error Screening</h2><br />
<DL>

<DT>None.<br />
<br />


</span>

<LI class="Heading0"><h1><A NAME="Contributors">Contributors</A></h1>
<span style="font-size:10pt;font-weight:normal;">
<p>
        Microchip gratefully acknowledges the contributions of the following
        to the development of MPLAB C Compiler for PIC18 MCUs.</p>
        <p>Daniel Madill, Quanser Consulting --<br />
        December 2000, Optimizations to fixed point divide library routines.</p>
</span>

<LI class="Heading0"><h1><A NAME="Support">Customer Support</A></h1>
<span style="font-size:10pt;font-weight:normal;">
<br />
        Microchip provides online support via our home page at:<br />
        <A HREF="http://www.microchip.com">http://www.microchip.com</A><br />
<br />
        Technical support is available through the web site at:<br />
        <A HREF="http://support.microchip.com">http://support.microchip.com</A><br />
<br />
        A forum for discussion of Microchip products and tools is
        available at:<br />
        <A HREF="http://forum.microchip.com">http://forum.microchip.com</A><br />
</span>
</OL>
</span>
</body>
</html>

